// Complete Web Server Example
// Demonstrates: HTTP server, routing, JSON, async, error handling

import std::http
import std::json
import std::collections::HashMap
import std::sync::RwLock

// Data models
struct User {
    id: i32,
    name: String,
    email: String,
}

struct CreateUserRequest {
    name: String,
    email: String,
}

// In-memory database (thread-safe)
struct Database {
    users: RwLock<HashMap<i32, User>>,
    next_id: RwLock<i32>,
}

impl Database {
    fn new() -> Self {
        Database {
            users: RwLock::new(HashMap::new()),
            next_id: RwLock::new(1),
        }
    }
    
    fn create_user(self, name: String, email: String) -> User {
        let id = {
            let mut next = self.next_id.write()
            let id = *next
            *next += 1
            id
        }
        
        let user = User { id, name, email }
        self.users.write().insert(id, user.clone())
        user
    }
    
    fn get_user(self, id: i32) -> Option<User> {
        self.users.read().get(&id).cloned()
    }
    
    fn list_users(self) -> Vec<User> {
        self.users.read().values().cloned().collect()
    }
    
    fn delete_user(self, id: i32) -> bool {
        self.users.write().remove(&id).is_some()
    }
}

// HTTP handlers
async fn handle_request(req: http.Request, db: &Database) -> http.Response {
    match (req.method(), req.path()) {
        ("GET", "/") => {
            http.Response::ok("Welcome to Fruti API")
        },
        
        ("GET", "/users") => {
            let users = db.list_users()
            http.Response::json(&users)
        },
        
        ("GET", path) if path.starts_with("/users/") => {
            let id_str = path.trim_start_prefix("/users/")
            match id_str.parse::<i32>() {
                Ok(id) => {
                    match db.get_user(id) {
                        Some(user) => http.Response::json(&user),
                        None => http.Response::not_found(),
                    }
                },
                Error(_) => http.Response::bad_request("Invalid user ID"),
            }
        },
        
        ("POST", "/users") => {
            match req.json::<CreateUserRequest>().await {
                Ok(create_req) => {
                    let user = db.create_user(create_req.name, create_req.email)
                    http.Response::json(&user).with_status(201)
                },
                Error(e) => {
                    http.Response::bad_request("Invalid JSON: {e}")
                },
            }
        },
        
        ("DELETE", path) if path.starts_with("/users/") => {
            let id_str = path.trim_start_prefix("/users/")
            match id_str.parse::<i32>() {
                Ok(id) => {
                    if db.delete_user(id) {
                        http.Response::no_content()
                    } else {
                        http.Response::not_found()
                    }
                },
                Error(_) => http.Response::bad_request("Invalid user ID"),
            }
        },
        
        _ => http.Response::not_found(),
    }
}

async fn main() {
    let db = Database::new()
    
    // Seed with sample data
    db.create_user("Alice", "alice@example.com")
    db.create_user("Bob", "bob@example.com")
    
    println("Starting server on http://localhost:8080")
    println("Try:")
    println("  curl http://localhost:8080/users")
    println("  curl http://localhost:8080/users/1")
    println("  curl -X POST -H 'Content-Type: application/json' \\")
    println("       -d '{\"name\":\"Charlie\",\"email\":\"charlie@example.com\"}' \\")
    println("       http://localhost:8080/users")
    
    let server = http.Server::new("0.0.0.0:8080")
    server.run(|req| handle_request(req, &db)).await
        .expect("Server error")
}
